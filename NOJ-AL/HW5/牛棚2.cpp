Description
农夫约翰想要在他的正方形农场上建造一座正方形大牛棚。他讨厌在他的农场中砍树，想找一个能够让他在空旷无树的地方修建牛棚的地方。
我们假定，他的农场划分成 N x N 的方格。输入数据中包括有树的方格的列表。
你的任务是计算并输出，在他的农场中，不需要砍树却能够修建的最大正方形牛棚。
牛棚的边必须和水平轴或者垂直轴平行。

考虑下面的方格，它表示农夫约翰的农场，‘.'表示没有树的方格，‘#'表示有树的方格

         1 2 3 4 5 6 7 8
       1 .  .   .  .  .  .  .  .
       2 . #   .  .  . # .  .
       3 .  .   .  .  .  .  .  .
       4 .  .   .  .  .  .  .  .
       5 .  .   .  .  .  .  .  .
       6 .  .  #  .  .  .  .  .
       7 .  .   .  .  .  .  .  .
       8 .  .   .  .  .  .  .  .
最大的牛棚是 5 x 5 的，可以建造在方格右下角的两个位置其中一个。
Input
 第 1 行: 两个整数： N （1 <= N <= 1000），农场的大小，和 T （1 <= T <= 10，000）有树的方格的数量

 第 2..T+1 行: 两个整数（1 <= 整数 <= N), 有树格子的横纵坐标

Output
 输出约翰的牛棚的最大边长。

Sample Input
8 3
2 2
2 6
6 3
Sample Output
5
HINT
 动态规划，用f（i，j）表示以i，j为左上角的正方形
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#include <iostream>
#include <cstdio>
using namespace std;
int a[1010][1010];//原地图
int f[1010][1010];//正方形

int main() {
	int N, M;
	int ans = 1;
	scanf("%d%d", &N, &M);
	for (int i = 1; i <= M; i++) {int x, y; scanf("%d%d", &x, &y); a[x][y] = 1;}

	for (int i = 1; i <= N; i++) {
		for (int j = 1; j <= N; j++) {
			if (a[i][j]) continue;
			else f[i][j] = min(min(f[i - 1][j], f[i][j - 1]), f[i - 1][j - 1]) + 1;//外围有一圈0
			ans = max(f[i][j], ans);
		}
	}
	printf("%d\n", ans);
	/*
		for (int i = 1; i <= N; i++) {
			for (int j = 1; j <= N; j++) {
				cout << f[i][j] << '\t';
			}
			cout << endl;
		}
	*/
	return 0;
}
