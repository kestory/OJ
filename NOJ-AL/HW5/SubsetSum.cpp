Description

对于从1到N (1 <= N <= 39) 的连续整数集合，能划分成两个子集合，且保证每个集合的数字和是相等的。
举个例子，如果N=3，对于{1，2，3}能划分成两个子集合，每个子集合的所有数字和是相等的：
{3} 和 {1,2}

这是唯一一种分法（交换集合位置被认为是同一种划分方案，因此不会增加划分方案总数）
如果N=7，有四种方法能划分集合{1，2，3，4，5，6，7}，每一种分法的子集合各数字和是相等的:
{1,6,7} 和 {2,3,4,5} {注 1+6+7=2+3+4+5}
{2,5,7} 和 {1,3,4,6}
{3,4,7} 和 {1,2,5,6}
{1,2,4,7} 和 {3,5,6}

Input
 输入只有一行，且只有一个整数N

Output
 输出划分方案总数，如果不存在则输出0。

Sample Input
7
Sample Output
4

HINT
 注意即便只有39结果也可能很大
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
先想到什么样的sum(0~i)和为偶，0011001100110011...隔两位会是。39时sum(0~39)=741//求和用循环不如直接求和公式。。
-------此题可以看作01背包问题
背包的容量为sum/2，原集合中的数字看为物品的重量（这里价值维度可以淡化，就像装箱问题）//value都是1
则原问题转化为 “从原集合中选出n个物品，使这n个物品恰好放满容量为sum/2的背包的方案总数”
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#include <iostream>
using namespace std;
int f[40][750];//39,741
int main()
{
	ios::sync_with_stdio(false);
	int n;
	cin >> n;

	int sum = (n + 1) * n >> 1;//求和公式
	if (sum & 1){//和为奇数先舍去
		cout << '0';
		return 0;
	}//或者直接判断sum为4的倍数OrNot

	//f[i,j]表示取前i个数，使set总数和为j的方案数
	f[1][1] = 1;
	for (int i = 2; i <= n; i++)//1的情况已经算完了，所以从2开始
		for (int j = 0; j <= sum; j++)
			f[i][j]=max(f[i-1][j]+f[i-1][j-i],f[i-1][j]);
			/*if (j > i)//取第i个数
				f[i][j] = f[i - 1][j] + f[i - 1][j - i];
			else//不取
				f[i][j] = f[i - 1][j];
			*/

	cout << f[n][sum / 2];
	return 0;
}
------------------------
用逆序优化为一维数组
n=39时方案数大于maxlongint（除以2之后小于maxlongint）15亿
------------------------
#include <cstdio>
int n,s;
long long f[400]={0};//这里很奇怪，400->4也能过
int main(){
	scanf("%d",&n);
	s=n*(n+1)/2;
	if (s&1){
		printf("0");
		return 0;
	}
	s/=2;
	f[0]=1;
	for (int i=1;i<=n;i++)
		for (int j=s;j>=i;j--)
			f[j]+=f[j-i];
	printf("%lld\n",(long long)f[s]/2);
}
