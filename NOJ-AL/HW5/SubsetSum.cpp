Description

 对于从1到N (1 <= N <= 39) 的连续整数集合，能划分成两个子集合，且保证每个集合的数字和是相等的。举个例子，如果N=3，对于{1，2，3}能划分成两个子集合，每个子集合的所有数字和是相等的：

{3} 和 {1,2}

这是唯一一种分法（交换集合位置被认为是同一种划分方案，因此不会增加划分方案总数） 如果N=7，有四种方法能划分集合{1，2，3，4，5，6，7}，每一种分法的子集合各数字和是相等的:

{1,6,7} 和 {2,3,4,5} {注 1+6+7=2+3+4+5}
{2,5,7} 和 {1,3,4,6}
{3,4,7} 和 {1,2,5,6}
{1,2,4,7} 和 {3,5,6}
Input

 输入只有一行，且只有一个整数N

Output

 输出划分方案总数，如果不存在则输出0。

Sample Input

7
Sample Output

4
HINT

 注意即便只有39结果也可能很大
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#include <iostream>
using namespace std;
int f[40][750];//39,741
int main()
{
	ios::sync_with_stdio(false);
	int n;
	cin >> n;

	int sum = (n + 1) * n >> 1;//求和公式
	if (sum & 1){//和为奇数先舍去
		cout << '0';
		return 0;
	}
	//这里重量和费用都是i
	//其中f[i][j]表示前i件物品中选取若干件物品放入剩余空间为j的背包中所能得到的最大价值
	f[1][1] = 1;
	f[1][0] = 1;
	for (int i = 2; i <= n; i++) //1的情况已经算完了，所以从2开始
		for (int j = 0; j <= sum; j++)
			if (j > i)//取
				f[i][j] = f[i - 1][j] + f[i - 1][j - i];
			else
				f[i][j] = f[i - 1][j];//不取

	cout << f[n][sum / 2];
	return 0;
}
